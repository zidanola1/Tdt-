//@version=6
indicator("DINC Candle Counter Pro", shorttitle="DINC Pro", overlay=true, max_labels_count=500, max_lines_count=500)

// Input parameters - Basic Settings
start_date = input.time(timestamp("2025-07-10 10:00"), "Start Date", group="Basic Settings")
sequence_type = input.string("custom", "Sequence Type", options=["custom", "sequence_7", "sequence_13", "sequence_21", "sequence_5", "sequence_9", "sequence_11", "time_expansion_1", "time_expansion_2", "time_expansion_3", "time_contraction_1", "time_contraction_2", "time_contraction_3", "time_distortion_1", "time_distortion_2", "time_distortion_3", "gann_cardinal", "gann_ordinal"], group="Basic Settings")
custom_sequence = input.string("1,7,13,21,33", "Custom Sequence", group="Basic Settings")
max_candles = input.int(100, "Number of Candles", minval=1, maxval=500, group="Basic Settings")

// Custom Sequences Toggle
use_custom_seq_1 = input.bool(false, "Use Custom Sequence 1", group="Custom Sequences")
custom_sequence_1 = input.string("7,13,21,31,42", "Custom Sequence 1", group="Custom Sequences")
use_custom_seq_2 = input.bool(false, "Use Custom Sequence 2", group="Custom Sequences") 
custom_sequence_2 = input.string("5,9,11,17,25,37", "Custom Sequence 2", group="Custom Sequences")

// Anchoring Settings
use_manual_anchor = input.bool(false, "Use Manual Anchor Point", group="Anchoring")
manual_anchor_bar = input.int(0, "Manual Anchor Bar Index (0=current)", group="Anchoring")
save_anchor_points = input.bool(true, "Save Anchor Points (Persistent)", group="Anchoring")

// Counting Direction
enable_backward_count = input.bool(false, "Enable Backward Counting", group="Counting Direction")
backward_sequence = input.string("7,13,21", "Backward Count Sequence", group="Counting Direction")

// Future Projections
enable_future_projections = input.bool(false, "Enable Future Projections", group="Future Projections")
projection_sequence = input.string("7,13,21", "Future Projection Sequence", group="Future Projections")

// Multi-Timeframe Settings
enable_mtf = input.bool(false, "Enable Multi-Timeframe Overlay", group="Multi-Timeframe")
higher_tf = input.timeframe("1H", "Higher Timeframe", group="Multi-Timeframe")
mtf_sequence = input.string("7,13,21", "MTF Sequence", group="Multi-Timeframe")
show_mtf_confluence = input.bool(true, "Show MTF Confluence Markers", group="Multi-Timeframe")

// EMA Settings
show_ema = input.bool(false, "Show EMA 8/21", group="EMA Settings")
ema_8_color = input.color(#0000FF, "EMA 8 Color", group="EMA Settings")
ema_21_color = input.color(#FF0000, "EMA 21 Color", group="EMA Settings")

// Time Distortion Enhanced
enhanced_td_detection = input.bool(true, "Enhanced Time Distortion (Doji) Detection", group="Time Distortion")
doji_threshold = input.float(0.1, "Doji Body Threshold (% of range)", minval=0.01, maxval=0.5, step=0.01, group="Time Distortion")
skip_time_distortion = input.bool(false, "Skip Time Distortion Candles", group="Time Distortion")

// Inside Candle Settings
inside_comparison = input.string("<=", "Inside Candle Comparison", options=["<", "<="], group="Time Distortion")
inside_use_hl = input.bool(true, "Use High/Low vs Open/Close for Inside Detection", group="Time Distortion")

// Display settings
display_position = input.string("above_candle", "Display Numbers Above/Below", options=["above_candle", "below_candle"], group="Display Settings")
vertical_shift = input.int(0, "Vertical Shift Above/Below", group="Display Settings")
normal_color = input.color(#808080, "Normal Number Color", group="Display Settings")
sequence_color = input.color(#FF0000, "Sequence Number Color", group="Display Settings")
backward_color = input.color(#800080, "Backward Count Color", group="Display Settings")
future_color = input.color(#FFA500, "Future Projection Color", group="Display Settings")
mtf_color = input.color(#00FFFF, "MTF Overlay Color", group="Display Settings")
confluence_color = input.color(#FFFF00, "Confluence Marker Color", group="Display Settings")
display_only_sequence = input.bool(true, "Display Only Sequence Numbers", group="Display Settings")
label_size = input.string("normal", "Label Size", options=["tiny", "small", "normal", "large", "huge"], group="Display Settings")
inputs_in_status = input.bool(true, "Inputs in Status Line", group="Display Settings")

// Enhanced sequences with proper counting starting from 1
get_sequence(string seq_type) =>
    switch seq_type
        "sequence_7" => "7,13,21,31,42"
        "sequence_13" => "13,21,25,31,42"
        "sequence_21" => "21,31,42,63"
        "sequence_5" => "5,9,11,17,25,37"
        "sequence_9" => "9,11,17,25,37"
        "sequence_11" => "11,17,25,37"
        "time_expansion_1" => "4,7,9,15"
        "time_expansion_2" => "7,11,15,19"
        "time_expansion_3" => "1,6,9,11"
        "time_contraction_1" => "3,4,7,8"
        "time_contraction_2" => "4,5,8,9"
        "time_contraction_3" => "2,3,6,7"
        "time_distortion_1" => "7,9,12,14"
        "time_distortion_2" => "8,11,13,15"
        "time_distortion_3" => "3,4,5,7"
        "gann_cardinal" => "1,2,4,8,16,32,64,128"
        "gann_ordinal" => "3,6,12,24,48,96,192"
        => custom_sequence

// Parse sequence string into array
parse_sequence(string seq_str) =>
    sequence = array.new<float>()
    parts = str.split(seq_str, ",")
    for part in parts
        trimmed_part = str.trim(part)
        if str.length(trimmed_part) > 0
            num_value = str.tonumber(trimmed_part)
            if not na(num_value)
                array.push(sequence, num_value)
    sequence

// Enhanced Doji Detection (Time Distortion)
is_doji_candle(int index) =>
    if index == 0
        candle_range = high - low
        body_size = math.abs(close - open)
        // Doji: Body is very small relative to the total range
        candle_range > 0 ? body_size / candle_range <= doji_threshold : false
    else
        candle_range = high[index] - low[index]
        body_size = math.abs(close[index] - open[index])
        candle_range > 0 ? body_size / candle_range <= doji_threshold : false

// Inside Candle Detection (High/Low comparison)
is_inside_candle_hl(int index) =>
    if index == 0 and bar_index > 0
        // Current candle compared to previous candle (High/Low)
        current_high = high
        current_low = low
        prev_high = high[1]
        prev_low = low[1]
        
        // Inside candle logic based on comparison setting
        if inside_comparison == "<="
            // Less than or equal: High <= prev_high AND Low >= prev_low
            current_high <= prev_high and current_low >= prev_low
        else
            // Strictly less than: High < prev_high AND Low > prev_low
            current_high < prev_high and current_low > prev_low
        
    else if index > 0
        // Historical candles
        current_high = high[index]
        current_low = low[index] 
        prev_high = high[index + 1]
        prev_low = low[index + 1]
        
        if inside_comparison == "<="
            current_high <= prev_high and current_low >= prev_low
        else
            current_high < prev_high and current_low > prev_low
    else
        false

// Inside Candle Detection (Open/Close comparison)
is_inside_candle_oc(int index) =>
    if index == 0 and bar_index > 0
        // Current candle compared to previous candle (Open/Close body)
        current_max = math.max(open, close)
        current_min = math.min(open, close)
        prev_max = math.max(open[1], close[1])
        prev_min = math.min(open[1], close[1])
        
        // Inside candle logic based on comparison setting
        if inside_comparison == "<="
            // Less than or equal: Body max <= prev body max AND Body min >= prev body min
            current_max <= prev_max and current_min >= prev_min
        else
            // Strictly less than: Body max < prev body max AND Body min > prev body min
            current_max < prev_max and current_min > prev_min
        
    else if index > 0
        // Historical candles
        current_max = math.max(open[index], close[index])
        current_min = math.min(open[index], close[index])
        prev_max = math.max(open[index + 1], close[index + 1])
        prev_min = math.min(open[index + 1], close[index + 1])
        
        if inside_comparison == "<="
            current_max <= prev_max and current_min >= prev_min
        else
            current_max < prev_max and current_min > prev_min
    else
        false

// Enhanced Time Distortion Detection (Clear Logic)
is_time_distortion_candle(int index) =>
    result = false
    if enhanced_td_detection
        // 1. Doji Detection: Very small body relative to range
        is_doji = is_doji_candle(index)
        
        // 2. Inside Candle Detection: Choose High/Low or Open/Close method
        is_inside = inside_use_hl ? is_inside_candle_hl(index) : is_inside_candle_oc(index)
        
        // 3. Small Range Detection: Significantly smaller than previous candle
        is_small_range = false
        if index == 0 and bar_index > 0
            current_range = high - low
            prev_range = high[1] - low[1]
            is_small_range := prev_range > 0 ? current_range < (prev_range * 0.6) : false
        else if index > 0
            current_range = high[index] - low[index]
            prev_range = high[index + 1] - low[index + 1]
            is_small_range := prev_range > 0 ? current_range < (prev_range * 0.6) : false
        
        // Time Distortion = Doji OR Inside Candle OR Small Range
        result := is_doji or is_inside or is_small_range
    result

// EMA Calculations
ema_8 = ta.ema(close, 8)
ema_21 = ta.ema(close, 21)

// Plot EMAs if enabled
plot(show_ema ? ema_8 : na, color=ema_8_color, linewidth=1, title="EMA 8")
plot(show_ema ? ema_21 : na, color=ema_21_color, linewidth=2, title="EMA 21")

// Persistent storage variables
var int anchor_bar_index = na
var int forward_count = 0
var int backward_count = 0
var bool counting_started = false
var array<label> all_labels = array.new<label>()
var line anchor_line = na
var int current_count_number = 1
var bool in_time_distortion = false
var int display_count = 1

// Multi-timeframe data request
[mtf_close, mtf_high, mtf_low, mtf_open, mtf_bar_index] = request.security(syminfo.tickerid, higher_tf, [close, high, low, open, bar_index])

// Get current sequences
current_sequence_str = get_sequence(sequence_type)
sequence_array = parse_sequence(current_sequence_str)

// Custom sequences
custom_seq_1_array = use_custom_seq_1 ? parse_sequence(custom_sequence_1) : array.new<float>()
custom_seq_2_array = use_custom_seq_2 ? parse_sequence(custom_sequence_2) : array.new<float>()
backward_seq_array = enable_backward_count ? parse_sequence(backward_sequence) : array.new<float>()
future_seq_array = enable_future_projections ? parse_sequence(projection_sequence) : array.new<float>()

// Get label size
get_label_size() =>
    switch label_size
        "tiny" => size.tiny
        "small" => size.small
        "large" => size.large
        "huge" => size.huge
        => size.normal

// Anchor point logic
if use_manual_anchor and manual_anchor_bar >= 0
    anchor_bar_index := bar_index - manual_anchor_bar
    counting_started := true
    forward_count := 1
    backward_count := 1
    current_count_number := 1
    in_time_distortion := false
    
    // Draw anchor line
    if not na(anchor_line)
        line.delete(anchor_line)
    anchor_line := line.new(anchor_bar_index, low, anchor_bar_index, high, color=#0000FF, width=3, style=line.style_solid)

else if time >= start_date and not counting_started
    anchor_bar_index := bar_index
    counting_started := true
    forward_count := 1
    backward_count := 1
    current_count_number := 1
    in_time_distortion := false
    
    // Draw anchor line
    anchor_line := line.new(bar_index, low, bar_index, high, color=#0000FF, width=3, style=line.style_solid)

// Forward counting logic with optional Time Distortion freeze behavior
if counting_started and current_count_number <= max_candles and bar_index >= anchor_bar_index
    // Check if TD detection is enabled AND if current candle is TD
    is_td = enhanced_td_detection and skip_time_distortion ? is_time_distortion_candle(0) : false
    
    // Determine display count BEFORE updating count
    display_count := current_count_number
    
    // Time Distortion Logic: Only apply if skip_time_distortion is enabled
    if is_td and skip_time_distortion
        // Mark as in time distortion state
        in_time_distortion := true
        
        // Show TD marker
        td_y = display_position == "above_candle" ? high + (high - low) * 0.05 + vertical_shift : low - (high - low) * 0.05 - vertical_shift
        td_label = label.new(bar_index, td_y, "×", color=color.new(#FFFFFF, 100), textcolor=color.new(#FF0000, 70), size=size.tiny, style=label.style_circle)
        array.push(all_labels, td_label)
        
        // DON'T increment count - keep showing same number (frozen)
        
    else
        // Normal candle OR TD detection disabled - advance count normally
        if in_time_distortion and not skip_time_distortion
            // If TD was previously detected but now disabled, reset state
            in_time_distortion := false
        
        if in_time_distortion and skip_time_distortion
            // Exiting time distortion - advance to next count
            current_count_number := current_count_number + 1
            in_time_distortion := false
        else
            // Normal progression
            current_count_number := current_count_number + 1
        
        // Update display count to new value
        display_count := current_count_number
    
    // Check ALL sequences for the current count
    is_main_sequence = array.includes(sequence_array, float(display_count))
    is_custom_1 = use_custom_seq_1 and array.includes(custom_seq_1_array, float(display_count))
    is_custom_2 = use_custom_seq_2 and array.includes(custom_seq_2_array, float(display_count))
    
    // Show ALL sequence hits with different colors and positions
    y_base = display_position == "above_candle" ? high + (high - low) * 0.1 + vertical_shift : low - (high - low) * 0.1 - vertical_shift
    
    // Main Sequence Label
    if not display_only_sequence or is_main_sequence
        label_text = if is_td and skip_time_distortion
            str.tostring(display_count) + "×"  // Add × to show it's frozen
        else
            str.tostring(display_count)
        
        main_color = if is_td and skip_time_distortion
            color.new(sequence_color, 50)  // Semi-transparent for TD
        else
            sequence_color
        
        if not display_only_sequence or is_main_sequence
            main_label = label.new(bar_index, y_base, label_text, color=color.new(#FFFFFF, 100), textcolor=main_color, size=get_label_size(), style=label.style_none)
            array.push(all_labels, main_label)
    
    // Custom Sequence 1 Label (if enabled and hit)
    if use_custom_seq_1 and is_custom_1
        custom1_text = if is_td and skip_time_distortion
            str.tostring(display_count) + "×"
        else
            str.tostring(display_count)
        
        custom1_color = if is_td and skip_time_distortion
            color.new(#00FF00, 50)  // Semi-transparent green for TD
        else
            #00FF00  // Green
        
        custom1_y = y_base + (display_position == "above_candle" ? (high - low) * 0.05 : -(high - low) * 0.05)
        custom1_label = label.new(bar_index, custom1_y, custom1_text + "₁", color=color.new(#FFFFFF, 100), textcolor=custom1_color, size=get_label_size(), style=label.style_none)
        array.push(all_labels, custom1_label)
    
    // Custom Sequence 2 Label (if enabled and hit)
    if use_custom_seq_2 and is_custom_2
        custom2_text = if is_td and skip_time_distortion
            str.tostring(display_count) + "×"
        else
            str.tostring(display_count)
        
        custom2_color = if is_td and skip_time_distortion
            color.new(#800080, 50)  // Semi-transparent purple for TD
        else
            #800080  // Purple
        
        custom2_y = y_base + (display_position == "above_candle" ? (high - low) * 0.08 : -(high - low) * 0.08)
        custom2_label = label.new(bar_index, custom2_y, custom2_text + "₂", color=color.new(#FFFFFF, 100), textcolor=custom2_color, size=get_label_size(), style=label.style_none)
        array.push(all_labels, custom2_label)

// Backward counting logic with TD freeze behavior using same TD detection
if enable_backward_count and counting_started and anchor_bar_index > 0
    for i = 1 to 50
        back_bar_index = anchor_bar_index - i
        if back_bar_index >= 0
            // Check if this historical bar was a TD candle using same logic as forward counting
            bars_back = bar_index - back_bar_index
            is_back_td = enhanced_td_detection and skip_time_distortion ? is_time_distortion_candle(bars_back) : false
            is_backward_sequence = array.includes(backward_seq_array, float(i))
            
            if is_backward_sequence
                back_high = high[bar_index - back_bar_index]
                back_low = low[bar_index - back_bar_index]
                back_range = back_high - back_low
                y_position = display_position == "above_candle" ? back_high + back_range * 0.1 : back_low - back_range * 0.1
                
                // Apply same TD formatting as forward counting
                label_text = if is_back_td and skip_time_distortion
                    "-" + str.tostring(i) + "×"  // × shows TD detected
                else
                    "-" + str.tostring(i)
                
                back_color = if is_back_td and skip_time_distortion
                    color.new(backward_color, 50)  // Semi-transparent for TD
                else
                    backward_color
                
                label_id = label.new(back_bar_index, y_position, label_text, color=color.new(#FFFFFF, 100), textcolor=back_color, size=get_label_size(), style=label.style_none)
                array.push(all_labels, label_id)

// Future projections with TD awareness
if enable_future_projections and counting_started
    for i = 1 to 21
        future_count = current_count_number + i
        is_future_sequence = array.includes(future_seq_array, float(future_count))
        if is_future_sequence
            future_bar_index = bar_index + i
            y_position = display_position == "above_candle" ? high + (high - low) * 0.1 : low - (high - low) * 0.1
            
            // Future projections show where count WOULD be (accounting for current TD state)
            label_text = if in_time_distortion
                "+" + str.tostring(future_count) + "?"  // ? indicates uncertainty due to current TD
            else
                "+" + str.tostring(future_count)
            
            future_final_color = if in_time_distortion
                color.new(future_color, 60)  // More transparent if currently in TD
            else
                future_color
            
            label_id = label.new(future_bar_index, y_position, label_text, color=color.new(#FFFFFF, 100), textcolor=future_final_color, size=get_label_size(), style=label.style_none)
            array.push(all_labels, label_id)

// Multi-timeframe confluence detection
if enable_mtf and show_mtf_confluence and counting_started
    current_bars = bar_index - anchor_bar_index + 1
    
    // Simple MTF count simulation (this would need more complex logic for real MTF)
    mtf_count = math.floor(current_bars / 4) // Simplified for demonstration
    mtf_sequence_array = parse_sequence(mtf_sequence)
    
    is_mtf_confluence = array.includes(mtf_sequence_array, float(current_bars)) and array.includes(mtf_sequence_array, float(mtf_count))
    if is_mtf_confluence
        confluence_y = display_position == "above_candle" ? high + (high - low) * 0.2 : low - (high - low) * 0.2
        confluence_label = label.new(bar_index, confluence_y, "◆", color=color.new(#FFFFFF, 100), textcolor=confluence_color, size=size.large, style=label.style_none)
        array.push(all_labels, confluence_label)

// Status line display
if inputs_in_status and barstate.islast
    status_parts = array.new<string>()
    array.push(status_parts, "DINC Pro: " + current_sequence_str)
    
    if counting_started
        status_suffix = in_time_distortion ? " (TD)" : ""
        array.push(status_parts, "Count: " + str.tostring(current_count_number) + status_suffix)
    
    if use_custom_seq_1
        array.push(status_parts, "Seq1: " + custom_sequence_1)
    if use_custom_seq_2
        array.push(status_parts, "Seq2: " + custom_sequence_2)
    if enable_backward_count
        array.push(status_parts, "Back: ON")
    if enable_future_projections
        array.push(status_parts, "Future: ON")
    if enable_mtf
        array.push(status_parts, "MTF: " + higher_tf)
    if enhanced_td_detection
        td_method = inside_use_hl ? "H/L" : "O/C"
        td_comparison = inside_comparison
        td_skip = skip_time_distortion ? "SKIP" : "SHOW"
        array.push(status_parts, "TD: " + td_skip + " (" + td_method + " " + td_comparison + ")")
    
    status_text = array.join(status_parts, " | ")
    var table status_table = table.new(position.top_right, 1, 1, bgcolor=color.new(#FFFFFF, 80), border_width=1)
    table.cell(status_table, 0, 0, status_text, text_color=#000000, text_size=size.tiny)

// Alert conditions
if counting_started and not in_time_distortion
    current_count_float = float(current_count_number)
    if array.includes(sequence_array, current_count_float)
        alert("DINC Sequence Number Reached: " + str.tostring(current_count_float), alert.freq_once_per_bar)
    
    if use_custom_seq_1 and array.includes(custom_seq_1_array, current_count_float)
        alert("Custom Sequence 1 Hit: " + str.tostring(current_count_float), alert.freq_once_per_bar)
    
    if use_custom_seq_2 and array.includes(custom_seq_2_array, current_count_float)
        alert("Custom Sequence 2 Hit: " + str.tostring(current_count_float), alert.freq_once_per_bar)

// Time Distortion alerts
if counting_started and enhanced_td_detection
    is_td_current = is_time_distortion_candle(0)
    if is_td_current and not in_time_distortion[1]
        alert("Time Distortion Detected - Count Frozen at: " + str.tostring(current_count_number), alert.freq_once_per_bar)
    
    if not is_td_current and in_time_distortion[1]
        alert("Time Distortion Ended - Count Resumed at: " + str.tostring(current_count_number), alert.freq_once_per_bar)