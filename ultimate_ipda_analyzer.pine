//@version=6
indicator("Ultimate IPDA Analyzer", shorttitle="IPDA Pro", overlay=true, max_labels_count=500, max_lines_count=500)

// === BASIC SETTINGS ===
start_date = input.time(timestamp("2025-01-15 09:30"), "Start Date", group="Basic Settings")
sequence_type = input.string("custom", "Sequence Type", options=["custom", "sequence_7", "sequence_13", "sequence_21", "gann_cardinal"], group="Basic Settings")
custom_sequence = input.string("7,13,21,31,42", "Custom Sequence", group="Basic Settings")
max_candles = input.int(100, "Number of Candles", minval=1, maxval=500, group="Basic Settings")

// === BACKWARD-TO-FORWARD CASTING (TDT) ===
enable_casting = input.bool(false, "Enable Backward-to-Forward Casting", group="TDT Casting")
backward_casting_sequence = input.string("33,27,21,13,7,3,1", "Backward Casting Sequence", group="TDT Casting")
enable_shift_mode = input.bool(false, "Enable Shift Mode", group="TDT Casting")
shift_seed = input.int(7, "Shift Seed", minval=1, maxval=100, group="TDT Casting")

// === TIME DISTORTION ===
freezeOnTD = input.bool(true, "Freeze Count on TD", group="Time Distortion")
enableAdvancedTD = input.bool(true, "Enhanced TD Detection", group="Time Distortion")
inside_method = input.string("High/Low", "Inside Detection Method", options=["High/Low", "Open/Close"], group="Time Distortion")
inside_comparison = input.string("<=", "Inside Comparison", options=["<=", "<"], group="Time Distortion")

// === DISPLAY SETTINGS ===
display_position = input.string("above_candle", "Display Position", options=["above_candle", "below_candle"], group="Display Settings")
sequence_color = input.color(#FF0000, "Sequence Number Color", group="Display Settings")
casting_color = input.color(#FF00FF, "Casting Color", group="Display Settings")
display_only_sequence = input.bool(true, "Display Only Sequence Numbers", group="Display Settings")

// === ENHANCED SEQUENCES ===
get_sequence(string seq_type) =>
    switch seq_type
        "sequence_7" => "7,13,21,31,42"
        "sequence_13" => "13,21,25,31,42"
        "sequence_21" => "21,31,42,63"
        "gann_cardinal" => "1,2,4,8,16,32,64,128"
        => custom_sequence

// === SEQUENCE PARSING ===
parse_sequence(string seq_str) =>
    sequence = array.new<float>()
    parts = str.split(seq_str, ",")
    for part in parts
        trimmed_part = str.trim(part)
        if str.length(trimmed_part) > 0
            num_value = str.tonumber(trimmed_part)
            if not na(num_value)
                array.push(sequence, num_value)
    sequence

// === TDT CASTING FUNCTIONS ===
get_forward_from_backward(string backward_seq) =>
    backward_array = parse_sequence(backward_seq)
    forward_array = array.new<float>()
    
    // Add numbers in reverse order, starting from the smallest
    for i = array.size(backward_array) - 1 to 0
        array.push(forward_array, array.get(backward_array, i))
    
    forward_array

// === TD DETECTION ===
is_ultimate_td_candle(int index) =>
    if not enableAdvancedTD
        false
    else
        c_high = high[index]
        c_low = low[index]
        c_open = open[index]
        c_close = close[index]
        
        prev_high = high[index + 1]
        prev_low = low[index + 1]
        prev_open = open[index + 1]
        prev_close = close[index + 1]
        
        // Inside candle detection
        is_inside = if inside_method == "High/Low"
            if inside_comparison == "<="
                c_high <= prev_high and c_low >= prev_low
            else
                c_high < prev_high and c_low > prev_low
        else
            bodyMax = math.max(c_open, c_close)
            bodyMin = math.min(c_open, c_close)
            prevBodyMax = math.max(prev_open, prev_close)
            prevBodyMin = math.min(prev_open, prev_close)
            
            if inside_comparison == "<="
                bodyMax <= prevBodyMax and bodyMin >= prevBodyMin
            else
                bodyMax < prevBodyMax and bodyMin > prevBodyMin
        
        is_inside

// === VARIABLES ===
var int anchor_bar_index = na
var bool counting_started = false
var int current_count_number = 1
var bool in_time_distortion = false
var int td_count = 0

// === TDT CASTING VARIABLES ===
var bool casting_active = false
var bool forward_cast_active = false
var int backward_cast_count = -33
var bool casting_phase_negative = true
var array<float> cast_forward_sequence = array.new<float>()
var int cast_forward_count = 0

// === SEQUENCE ARRAYS ===
current_sequence_str = get_sequence(sequence_type)
sequence_array = parse_sequence(current_sequence_str)
casting_seq_array = enable_casting ? parse_sequence(backward_casting_sequence) : array.new<float>()

// === ANCHOR POINT LOGIC ===
if time >= start_date and not counting_started
    anchor_bar_index := bar_index
    counting_started := true
    // Apply shift mode to initial count
    current_count_number := enable_shift_mode ? shift_seed : 1
    in_time_distortion := false

// === TD DETECTION FOR CURRENT BAR ===
current_is_td = is_ultimate_td_candle(0)

// === TDT BACKWARD CASTING LOGIC ===
if enable_casting and counting_started
    if not (current_is_td and freezeOnTD)
        if casting_phase_negative
            // NEGATIVE PHASE: Check if we hit a sequence number
            negative_hit = array.includes(casting_seq_array, float(math.abs(backward_cast_count)))
            
            // Check if we reached -1 (trigger point)
            if backward_cast_count == -1
                // Switch to positive phase with reversed sequence
                casting_phase_negative := false
                casting_active := true
                forward_cast_active := true
                cast_forward_sequence := get_forward_from_backward(backward_casting_sequence)
                cast_forward_count := 1
            else
                // Continue negative counting (moving toward -1)
                backward_cast_count := backward_cast_count + 1
        else
            // POSITIVE PHASE: Forward cast counting
            if forward_cast_active
                cast_forward_count := cast_forward_count + 1

// === MAIN COUNTING LOGIC ===
if counting_started and current_count_number <= max_candles and bar_index > anchor_bar_index
    
    // TD Freeze Logic
    if current_is_td and freezeOnTD
        in_time_distortion := true
        td_count := td_count + 1
        // DON'T increment count - keep frozen
    else
        // Normal progression
        if in_time_distortion and freezeOnTD
            // Exiting TD - advance count
            current_count_number := current_count_number + 1
            in_time_distortion := false
            td_count := 0
        else
            // Normal progression
            current_count_number := current_count_number + 1
            td_count := 0
    
    // === SEQUENCE DETECTION ===
    is_main_sequence = array.includes(sequence_array, float(current_count_number))
    
    range_mult = (high - low) * 0.1
    y_base = display_position == "above_candle" ? high + range_mult : low - range_mult
    
    // === MAIN SEQUENCE LABELS ===
    if not display_only_sequence or is_main_sequence
        label_text = if current_is_td and freezeOnTD
            str.tostring(current_count_number) + "Ã—"
        else
            str.tostring(current_count_number)
        
        main_color = if current_is_td and freezeOnTD
            color.new(sequence_color, 50)
        else
            sequence_color
        
        if not display_only_sequence or is_main_sequence
            label.new(bar_index, y_base, label_text, color=color.new(#FFFFFF, 100), textcolor=main_color, size=size.normal)

// === TDT CASTING DISPLAY ===
if enable_casting and counting_started
    if casting_phase_negative
        // NEGATIVE PHASE: Display negative numbers when they hit sequence
        negative_hit = array.includes(casting_seq_array, float(math.abs(backward_cast_count)))
        if negative_hit
            casting_offset = (high - low) * 0.12
            casting_y = display_position == "above_candle" ? high + casting_offset : low - casting_offset
            casting_text = str.tostring(backward_cast_count) + "B"
            label.new(bar_index, casting_y, casting_text, color=color.new(#FFFFFF, 100), textcolor=casting_color, size=size.small)
    else
        // POSITIVE PHASE: Display forward casting hits
        if forward_cast_active
            forward_cast_hit = array.includes(cast_forward_sequence, float(cast_forward_count))
            if forward_cast_hit
                forward_offset = (high - low) * 0.15
                forward_y = display_position == "above_candle" ? high + forward_offset : low - forward_offset
                forward_text = str.tostring(cast_forward_count) + "F"
                label.new(bar_index, forward_y, forward_text, color=color.new(#FFFFFF, 100), textcolor=casting_color, size=size.small)

// === ALERTS ===
if counting_started and not in_time_distortion
    current_count_float = float(current_count_number)
    if array.includes(sequence_array, current_count_float)
        alert("IPDA Sequence Number Reached: " + str.tostring(current_count_float), alert.freq_once_per_bar)

// TDT Casting alerts
if enable_casting and casting_active and not casting_active[1]
    alert("TDT Casting Activated - Forward Count Started", alert.freq_once_per_bar)

if enable_casting and forward_cast_active
    forward_cast_hit = array.includes(cast_forward_sequence, float(cast_forward_count))
    if forward_cast_hit
        alert("TDT Forward Cast Hit: " + str.tostring(cast_forward_count), alert.freq_once_per_bar)

// === STATUS TABLE ===
if barstate.islast
    var table status_table = table.new(position.top_right, 2, 6, bgcolor=color.new(#FFFFFF, 80), border_width=1)
    table.cell(status_table, 0, 0, "Status", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 1, 0, "Value", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 0, 1, "Counting", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 1, 1, str.tostring(counting_started), text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 0, 2, "Count", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 1, 2, str.tostring(current_count_number), text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 0, 3, "Cast Phase", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 1, 3, casting_phase_negative ? "NEG" : "POS", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 0, 4, "Cast Count", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 1, 4, casting_phase_negative ? str.tostring(backward_cast_count) : str.tostring(cast_forward_count), text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 0, 5, "TD", text_color=#000000, text_size=size.tiny)
    table.cell(status_table, 1, 5, str.tostring(current_is_td), text_color=#000000, text_size=size.tiny)