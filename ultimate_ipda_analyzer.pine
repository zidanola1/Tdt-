//@version=6
indicator("Ultimate IPDA Analyzer", overlay=true, max_labels_count=500, max_lines_count=500)

// === INPUTS ===
// === BASIC SETTINGS ===
start_date = input.time(timestamp("2025-07-10 10:00"), "Start Date", group="Basic Settings")
sequence_type = input.string("custom", "Sequence Type", options=["custom", "sequence_7", "sequence_13", "sequence_21", "gann_cardinal"], group="Basic Settings")
custom_sequence = input.string("7,13,21,31,42", "Custom Sequence", group="Basic Settings")
max_candles = input.int(100, "Number of Candles", minval=1, maxval=500, group="Basic Settings")

// === BACKWARD-TO-FORWARD CASTING (TDT) ===
enable_casting = input.bool(true, "Enable Backward-to-Forward Casting", group="TDT Casting", tooltip="When backward count reaches '1', auto-start forward count with same sequence")
backward_sequence = input.string("33,27,21,13,7,3,1", "Backward Sequence", group="TDT Casting", tooltip="Sequence for backward counting from pivot")
enable_shift_mode = input.bool(false, "Enable Shift Mode", group="TDT Casting", tooltip="Replace normal start count of '1' with chosen seed")
shift_seed = input.int(7, "Shift Seed", minval=1, maxval=100, group="TDT Casting", tooltip="Starting count when Shift Mode is ON (e.g., 7, 13, 21)")
casting_visual = input.bool(true, "Show Casting Transitions", group="TDT Casting", tooltip="Visual markers for backward-to-forward transitions")

// === IPDA TIME DISTORTION ===
enableAdvancedTD = input.bool(true, "Enable Time Distortion Detection", group="IPDA Time Distortion")
inside_method = input.string("High/Low", "Inside Detection Method", options=["High/Low", "Open/Close"], group="IPDA Time Distortion")
inside_comparison = input.string("<=", "Inside Comparison", options=["<=", "<"], group="IPDA Time Distortion")
freezeOnTD = input.bool(true, "Freeze Count on TD", group="IPDA Time Distortion")

// === COUNTING SETTINGS ===
enable_backward = input.bool(true, "Enable Backward Count", group="Counting Settings")
enable_future = input.bool(true, "Enable Future Count", group="Counting Settings")
future_sequence = input.string("7,13,21,31,42", "Future Sequence", group="Counting Settings")
anchor_bar = input.int(0, "Manual Anchor Bar", minval=0, group="Counting Settings")

// === MULTI-TIMEFRAME ===
enable_mtf = input.bool(false, "Enable Multi-Timeframe", group="Multi-Timeframe")
mtf_timeframe = input.timeframe("5m", "MTF Timeframe", group="Multi-Timeframe")
show_mtf_confluence = input.bool(true, "Show MTF Confluence", group="Multi-Timeframe")

// === EMA OVERLAYS ===
show_ema8 = input.bool(true, "Show EMA 8", group="EMA Overlays")
show_ema21 = input.bool(true, "Show EMA 21", group="EMA Overlays")
ema8_color = input.color(#2962FF, "EMA 8 Color", group="EMA Overlays")
ema21_color = input.color(#FF6D00, "EMA 21 Color", group="EMA Overlays")

// === DISPLAY SETTINGS ===
show_sequence_labels = input.bool(true, "Show Sequence Labels", group="Display Settings")
show_backward_labels = input.bool(true, "Show Backward Labels", group="Display Settings")
show_future_labels = input.bool(true, "Show Future Labels", group="Display Settings")
display_position = input.string("above_candle", "Display Position", options=["above_candle", "below_candle"], group="Display Settings")
label_color_main = input.color(#00FF00, "Main Sequence Color", group="Display Settings")
label_color_backward = input.color(#FF0000, "Backward Color", group="Display Settings")
label_color_future = input.color(#0000FF, "Future Color", group="Display Settings")
label_color_casting = input.color(#FF00FF, "Casting Transition Color", group="Display Settings")
show_td_background = input.bool(true, "Show TD Background", group="Display Settings")
td_bg_color = input.color(color.new(#FFFF00, 80), "TD Background Color", group="Display Settings")
label_size = input.string("normal", "Label Size", options=["tiny", "small", "normal", "large", "huge"], group="Display Settings")
show_sequence_lines = input.bool(false, "Show Sequence Lines", group="Display Settings")
inputs_in_status = input.bool(true, "Show Status Line", group="Display Settings")

// === ENHANCED SEQUENCES ===
// Note: Use custom_sequence input to enter any sequence like: 5,9,11,17,25,37
get_sequence(string seq_type) =>
    switch seq_type
        "sequence_7" => "7,13,21,31,42"
        "sequence_13" => "13,21,25,31,42"
        "sequence_21" => "21,31,42,63"
        "gann_cardinal" => "1,2,4,8,16,32,64,128"
        => custom_sequence

// === TDT CASTING FUNCTIONS ===
// Parse sequence string to array
parse_sequence(string seq_str) =>
    seq_array = array.new<float>()
    seq_parts = str.split(seq_str, ",")
    for i = 0 to array.size(seq_parts) - 1
        num_str = str.trim(array.get(seq_parts, i))
        if num_str != ""
            array.push(seq_array, str.tonumber(num_str))
    seq_array

// Get forward sequence from backward sequence (reverse and start from 1)
get_forward_from_backward(string backward_seq) =>
    backward_array = parse_sequence(backward_seq)
    forward_array = array.new<float>()
    
    // Add numbers in reverse order, starting from the smallest
    for i = array.size(backward_array) - 1 to 0
        array.push(forward_array, array.get(backward_array, i))
    
    forward_array

// Get shifted sequence starting from seed
get_shifted_sequence(string base_seq, int seed) =>
    base_array = parse_sequence(base_seq)
    shifted_array = array.new<float>()
    
    // Find starting position in sequence
    start_index = -1
    for i = 0 to array.size(base_array) - 1
        if array.get(base_array, i) == seed
            start_index := i
            break
    
    // If seed found, start from that position
    if start_index >= 0
        for i = start_index to array.size(base_array) - 1
            array.push(shifted_array, array.get(base_array, i))
    else
        // If seed not found, add it as first element and continue with sequence
        array.push(shifted_array, float(seed))
        for i = 0 to array.size(base_array) - 1
            if array.get(base_array, i) > seed
                array.push(shifted_array, array.get(base_array, i))
    
    shifted_array

// === SEQUENCE PARSING ===
selected_sequence = get_sequence(sequence_type)
main_seq_array = parse_sequence(selected_sequence)
backward_seq_array = parse_sequence(backward_sequence)
future_seq_array = parse_sequence(future_sequence)

// === ULTIMATE TD DETECTION (Combined Logic) ===
is_ultimate_td_candle(int index) =>
    if not enableAdvancedTD
        false
    else
        // Get candle data using proper historical referencing
        c_high = high[index]
        c_low = low[index]
        c_open = open[index]
        c_close = close[index]
        
        prev_high = high[index + 1]
        prev_low = low[index + 1]
        prev_open = open[index + 1]
        prev_close = close[index + 1]
        
        // Basic calculations
        candleRange = c_high - c_low
        bodySize = math.abs(c_close - c_open)
        prevRange = prev_high - prev_low
        
        // Inside candle detection
        is_inside = if inside_method == "High/Low"
            if inside_comparison == "<="
                c_high <= prev_high and c_low >= prev_low
            else
                c_high < prev_high and c_low > prev_low
        else
            current_max = math.max(c_open, c_close)
            current_min = math.min(c_open, c_close)
            prev_max = math.max(prev_open, prev_close)
            prev_min = math.min(prev_open, prev_close)
            if inside_comparison == "<="
                current_max <= prev_max and current_min >= prev_min
            else
                current_max < prev_max and current_min > prev_min
        
        // Small range detection
        avg_range = (candleRange + prevRange) / 2
        is_small_range = candleRange <= avg_range * 0.5
        
        // Doji detection
        is_doji = bodySize <= candleRange * 0.1
        
        // Combined TD logic - prioritize inside candle
        is_inside or is_small_range or is_doji

// === VARIABLES ===
var int candle_count = 0
var int current_count = 1
var int backward_count = 0
var int future_count = 0
var bool in_time_distortion = false
var int td_count = 0
var bool is_counting = false
var bool is_backward_counting = false
var bool is_future_counting = false

// === TDT CASTING VARIABLES ===
var bool casting_active = false
var bool forward_cast_active = false
var int cast_pivot_bar = 0
var array<float> cast_forward_sequence = array.new<float>()
var int cast_forward_count = 0

// === UPDATE VARIABLES ===
if time >= start_date
    candle_count := candle_count + 1
    is_counting := true

// Detect current TD
current_is_td = is_ultimate_td_candle(0)

// Update TD state
if current_is_td and not in_time_distortion
    in_time_distortion := true
    td_count := 1
else if current_is_td and in_time_distortion
    td_count := td_count + 1
else if not current_is_td and in_time_distortion
    in_time_distortion := false
    td_count := 0

// === MAIN COUNTING LOGIC WITH TDT CASTING ===
if is_counting
    // Check if we should freeze on TD
    should_freeze = freezeOnTD and current_is_td
    
    if not should_freeze
        // Main sequence counting - increment first, then check
        current_count := current_count + 1
        
        // Check for casting trigger (backward count reaches 1)
        if enable_casting and is_backward_counting and enable_backward
            is_backward_hit = array.includes(backward_seq_array, float(backward_count))
            if is_backward_hit and backward_count == 1
                // Trigger forward casting
                casting_active := true
                forward_cast_active := true
                cast_pivot_bar := candle_count
                
                // Setup forward sequence
                if enable_shift_mode
                    cast_forward_sequence := get_shifted_sequence(backward_sequence, shift_seed)
                    cast_forward_count := shift_seed
                else
                    cast_forward_sequence := get_forward_from_backward(backward_sequence)
                    cast_forward_count := 1
        
        // Forward cast counting
        if forward_cast_active
            cast_forward_count := cast_forward_count + 1

// === BACKWARD COUNTING WITH CASTING ===
if enable_backward and is_counting
    should_freeze_back = freezeOnTD and current_is_td
    
    if not should_freeze_back
        if not is_backward_counting
            is_backward_counting := true
            backward_count := 1  // Start counting backward from 1
        else
            backward_count := backward_count + 1

// === FUTURE COUNTING ===
if enable_future and is_counting
    should_freeze_future = freezeOnTD and current_is_td
    
    if not should_freeze_future
        if not is_future_counting
            is_future_counting := true
            future_count := 1
        else
            future_count := future_count + 1

// === LABEL SIZE FUNCTION ===
get_label_size() =>
    switch label_size
        "tiny" => size.tiny
        "small" => size.small
        "large" => size.large
        "huge" => size.huge
        => size.normal

// === DISPLAY LOGIC ===
var string display_count = ""
current_count_float = float(current_count)

// Always show count labels for debugging
if show_sequence_labels and is_counting
    candle_range = high - low
    offset = candle_range * 0.1
    y_position = display_position == "above_candle" ? high + offset : low - offset
    
    // Show all counts, highlight sequence hits
    label_text = str.tostring(current_count)
    label_color = array.includes(main_seq_array, current_count_float) ? label_color_main : color.gray
    
    if inputs_in_status
        label_text := label_text + (array.includes(main_seq_array, current_count_float) ? " [HIT]" : " [Main]")
    
    label.new(bar_index, y_position, label_text, color=label_color, 
              textcolor=color.white, size=get_label_size())

// === BACKWARD DISPLAY ===
if enable_backward and show_backward_labels and is_backward_counting
    is_backward_sequence = array.includes(backward_seq_array, float(backward_count))
    
    if is_backward_sequence
            candle_range = high - low
            offset = candle_range * 0.15
            y_position = display_position == "above_candle" ? high + offset : low - offset
            
            label_text = str.tostring(backward_count) + "B"
            if inputs_in_status
                label_text := label_text + " [Back]"
            
            label.new(bar_index, y_position, label_text, color=label_color_backward, 
                      textcolor=color.white, size=get_label_size())

// === FORWARD CAST DISPLAY ===
if forward_cast_active and casting_visual
    is_cast_hit = array.includes(cast_forward_sequence, float(cast_forward_count))
    
    if is_cast_hit
        candle_range = high - low
        offset = candle_range * 0.2
        y_position = display_position == "above_candle" ? high + offset : low - offset
        
        label_text = str.tostring(cast_forward_count) + "F"
        if enable_shift_mode
            label_text := label_text + "S"  // Indicate shift mode
        if inputs_in_status
            label_text := label_text + " [Cast]"
        
        label.new(bar_index, y_position, label_text, color=label_color_casting, 
                  textcolor=color.white, size=get_label_size())

// === FUTURE DISPLAY ===
if enable_future and show_future_labels and is_future_counting
    is_future_sequence = array.includes(future_seq_array, float(future_count))
    
    if is_future_sequence
            candle_range = high - low
            offset = candle_range * 0.25
            y_position = display_position == "above_candle" ? high + offset : low - offset
            
            label_text = str.tostring(future_count) + "Fut"
            if inputs_in_status
                label_text := label_text + " [Future]"
            
            label.new(bar_index, y_position, label_text, color=label_color_future, 
                      textcolor=color.white, size=get_label_size())

// === TD BACKGROUND ===
bgcolor(show_td_background and current_is_td ? td_bg_color : na, title="TD Background")

// === DEBUG STATUS TABLE ===
if inputs_in_status and barstate.islast
    var table debug_table = table.new(position.top_right, 2, 6, bgcolor=color.new(color.white, 80), border_width=1)
    table.cell(debug_table, 0, 0, "Status", text_color=color.black, text_size=size.small)
    table.cell(debug_table, 1, 0, "Value", text_color=color.black, text_size=size.small)
    table.cell(debug_table, 0, 1, "Counting", text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 1, 1, str.tostring(is_counting), text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 0, 2, "Main Count", text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 1, 2, str.tostring(current_count), text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 0, 3, "Back Count", text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 1, 3, str.tostring(backward_count), text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 0, 4, "Time OK", text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 1, 4, str.tostring(time >= start_date), text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 0, 5, "TD Active", text_color=color.black, text_size=size.tiny)
    table.cell(debug_table, 1, 5, str.tostring(current_is_td), text_color=color.black, text_size=size.tiny)

// === EMA OVERLAYS ===
ema8 = ta.ema(close, 8)
ema21 = ta.ema(close, 21)

plot(show_ema8 ? ema8 : na, color=ema8_color, linewidth=2, title="EMA 8")
plot(show_ema21 ? ema21 : na, color=ema21_color, linewidth=2, title="EMA 21")

// === ALERTS ===
if array.includes(main_seq_array, current_count_float)
    if current_count_float == 7
        alert("Main Sequence Hit: 7", alert.freq_once_per_bar)
    if current_count_float == 13
        alert("Main Sequence Hit: 13", alert.freq_once_per_bar)
    if current_count_float == 21
        alert("Main Sequence Hit: 21", alert.freq_once_per_bar)

// Casting alerts
if casting_active and not casting_active[1]
    alert("TDT Casting Activated - Forward Count Started", alert.freq_once_per_bar)

if forward_cast_active and array.includes(cast_forward_sequence, float(cast_forward_count))
    alert("Cast Forward Hit: " + str.tostring(cast_forward_count), alert.freq_once_per_bar)

// TD-specific alerts
if enableAdvancedTD
    prev_is_td = ta.valuewhen(candle_count > 0, current_is_td, 1)
    if current_is_td and not prev_is_td
        alert("Time Distortion Detected", alert.freq_once_per_bar)
    
    if not current_is_td and prev_is_td and in_time_distortion
        alert("Time Distortion Ended - Count Resumed", alert.freq_once_per_bar)
    
    if td_count >= 3
        alert("Extended Time Distortion: " + str.tostring(td_count) + " candles", alert.freq_once_per_bar)